재고 할당/검증 프로세스를 바꾸면서 실제 재고량보다 많은 주문이 생성되는 이슈가 발생했습니다.

원인은 재고의 동시성(DB 락 같은 기술적 동시성이 아님)을 고려하지 못 한 설계 때문이었습니다.

## *** 서비스의 상품-재고 구조

![Untitled (2)](https://user-images.githubusercontent.com/3108214/137777530-9c44e76a-a778-447a-a3ef-eca491e3d6a3.png)

그림 1

*** 서비스는 재고 1개가 product_stock 테이블의 1행으로 저장되어 있습니다. 즉, A 상품의 재고가 3개 있다면 product_stock에도 3행이 들어 있습니다. 이후 상품이 판매되어 재고가 소진되면 product_sold_stock에도 해당 재고 데이터를 생성합니다. 위 `그림 1`에서 보면 A의 재고 3개 중 1개가 판매되어서 product_sold_stock 테이블에 stock A-1이 생성되었습니다.

기존 시스템에서는 오직 결제가 성공한 이후에만 product_sold_stock 테이블에 데이터가 추가/삭제되었지만, 프로세스 변경 후에는 사용자가 주문페이지에 진입할 때부터 매우 동적으로 product_sold_stock 테이블의 데이터가 수정됩니다. **즉, product_sold_stock 테이블에 영향을 주는 서비스와 상황이 급격히 늘어난 것입니다.**

무엇보다 중요한 것은 사용자가 주문페이지에 진입하고 3분이 지난 후에 그 사용자가 주문하려고 했던 재고들을 다시 원상복구 시키는 로직이었습니다. 주문페이지 진입 시점에서는 해당 사용자가 주문을 하지 않을지, 주문을 시도하지만 결제가 실패할지, 결제까지 성공할지 모르기 때문에 모든 가능성에 대한 트리거는 당겨 놓아야 합니다. 그렇기 때문에 일단 SQS 지연 큐를 이용해서 재고 복구 요청을 보내놓고, 큐에서 메시지를 수신하는 시점에 메시지의 사용자가 어떻게 행동을 했는지 검증한 뒤 재고를 복구하거나 복구하지 않습니다. 하지만 한 재고에 대해서 여러 지연 큐 메시지가 얽히게 되는 경우를 처리하지 못 했습니다.

정리하면 여러 MSA 서버가 얽힌 비동기 프로세스를 **한 트랜잭션**으로 컨트롤 했어야 했는데, 이런 부분을 간과했습니다.

## 오버부킹 케이스 1

![Untitled (3)](https://user-images.githubusercontent.com/3108214/137777562-1ecef93b-cf21-42f2-8403-5027acb09ee7.png)


그림 2

위 `그림 2`는 오버부킹의 원인 중 하나를 도식화한 것 입니다.

원형 `user A`는 사용자 A가 재고를 획득한 시점, 그리고 화살표를 따라 `3min`까지 시간이 흐릅니다.

도중에 A는 변심을 해서 주문을 끝마치지 않고 `cancel` 지점에서 주문페이지를 벗어납니다.

재고를 점유하던 A가 이탈했기 때문에 재고 복구가 발생하고, `user B`가 해당 재고를 점유합니다.

B는 빠르게 주문을 마칩니다.

그러나 B의 주문이 끝난 후 A가 주문페이지에 진입할 때 발생한 재고 복구 메시지가 활성화되고, 검증 로직이 이 경우를 처리하지 못해서 B가 주문한 상품의 재고가 다시 복구되어 버립니다. 그 결과 또다른 사용자가 B가 주문했던 재고로 다시 주문할 수 있습니다.

물론, 지연된 복구 메시지를 검증할 때 해당 재고로 주문이 생성 되었는지는 고려하지만, 메시지의 사용자가 생성한 주문이 있는지만 검증했기 때문에 그림 2의 `Restore Stocks` 상황에서 재고를 복구합니다.

## 오버부킹 케이스 2

![Untitled (4)](https://user-images.githubusercontent.com/3108214/137777610-f35fc58c-5f2f-4e67-a6f8-be4211d93e04.png)


그림 3

`그림 3`도 오버부킹의 원인입니다.

`user A`가 주문페이지에 진입 후 3분이 지나기 전에 결제창을 띄웁니다.

A가 결제를 마치기 전에 3분이 지나고, A는 주문을 완료하지 않았기 때문에 재고가 복구됩니다.

이후 `user B`가 동일한 상품을 구매하려 합니다.

A는 3분이 지난 후에 결제를 완료했지만 그 사이에 B가 재고를 대신 잡아줬고, 재고가 온전하게 할당되어 있으므로 시스템은 A의 주문을 생성합니다.

B도 결제를 마치고 주문이 생성됩니다.

이 경우는 주문을 생성할 때 미리 잡은 재고의 주인을 추적하지 못 했기 때문에 오버부킹이 발생했습니다.

## 추가된 재고 복구 검증

- 재고 ID로 어떤 사용자든 온전히 생성한 주문이 있으면 재고를 복구하지 않습니다.
- 재고를 할당할 때 주문 트랜잭션 ID(payment_order_id)를 product_sold_stock 테이블에 넣어서 같은 트랜잭션일때만 재고를 복구합니다.

## 추가된 주문 생성 검증

- 주문페이지에 진입할 때 시간과 주문 생성 요청시 시간을 비교해서 170초(버퍼 10초) 이내인지 검증.
- 미리 할당된 재고의 트랜잭션 ID와 주문 생성 요청한 트랜잭션 ID가 동일한지 검증.
- 해당 상품에 대한 원재고량과 현재 판매량을 비교.
