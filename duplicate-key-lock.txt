# 5. 테스트 결과 정리

가장 중요한 이슈는 product_stock_id의 duplicate key 익셉션과 Deadlock, Connection TImeout(트랜잭션 생성 불가)였습니다.

(위 링크 중 4. 부하 테스트 결과 > 2021-06-23 참고)

원인은 아래 이유 때문이라고 판단했습니다.

**INSERT 경쟁 상황**

- A, B, C 순서로 같은 key값을 가지는 데이터를 INSERT 하기 위해 경쟁
- A 에서 `INSERT INTO table (pk) VALUES (3);` 실행하면 A에서 exclusive lock 획득
- B와 C에서도 동일한 INSERT 구문 실행한다. (B, C는 대기상태로 빠짐)
- A를 rollback하는 순간 B, C가 경쟁 시작.
- INSERT의 경우 exclusive lock을 획득 시도해야하지만, 
    해당 INSERT에서 **duplicated key error**가 발생하는 경우에는 해당 인덱스 레코드에 대해 일단 **shared lock**을 먼저 획득 시도하는 특성이 있다.
- B, C가 동일 인덱스 레코드에 대해 shared lock을 먼저 획득한 후 exclusive lock을 잡으려고 하기 때문에 데드락이 발생. 
    (B가 exclusive lock을 획득하려 해도 C가 획득한 shared lock에 의해 불가능, C -> B의 경우에도 vice versa)
- 늦게 실행된 C가 deadlock처리되어 트랜잭션이 롤백되어 종료되면, B가 exclusive lock을 획득하여 실행된다.
- A를 commit하면 B, C는 바로 duplicated key error가 발생하지만 여전히 트랜잭션은 열려있다.
- 

결국 이런 INSERT 상황에서 선행 트랜잭션이 rollback하게되면 나머지 트랜잭션들 중 하나만 성공하고 나머지는 모두 데드락으로 강제 롤백 된다는 것을 알 수 있다. 
이 케이스는 얼핏 봐서는 데드락이 발생하지 않을 것 같은 상황처럼 보이기 때문에 문제 발견이 쉽지 않으므로 기억해두는 것이 좋다.


실제로 아래처럼 코드로 직접 트랜잭션을 제어하면서 DB의 락 테이블을 조사해봤습니다

```java
do {
            DefaultTransactionDefinition def = new DefaultTransactionDefinition();
            def.setName("ReserveStockTx");
            def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
            TransactionStatus status = transactionManager.getTransaction(def);

            try {
                insertProductSoldStock(result);
                isSuccess = true;
            } catch (DataIntegrityViolationException e) {
                e.printStackTrace();

                log.info("ROLLBACK! > " + def.getName());
                transactionManager.rollback(status);

                // 누군가 먼저 재고를 사용(결제)해서 duplicate exception 발생하면 재고 재조회
                result = getAvailableProductStockList(productRootRepositoryParam);
                log.debug("productUseStockList.size(): {}", productReserveStockList.size());

            } catch (Exception e) {
                transactionManager.rollback(status);
                throw new DcodeApiException(e);
            }

        } while (!isSuccess);
```

### SELECT * FROM INNODB_LOCKS;

2372789033:4604:761:458, 2372789033, **S**, RECORD, `dcode`.`product_sold_stock`, unique_product_stock_id, 4604, 761, 458, **428744**
**2372789024:4604:761:458**, **2372789024**, **X**, RECORD, `dcode`.`product_sold_stock`, unique_product_stock_id, 4604, 761, 458, **428744**
2372789032:4604:761:458, 2372789032, **S**, RECORD, `dcode`.`product_sold_stock`, unique_product_stock_id, 4604, 761, 458, **428744**
2372789031:4604:761:458, 2372789031, **S**, RECORD, `dcode`.`product_sold_stock`, unique_product_stock_id, 4604, 761, 458, **428744**
2372789030:4604:761:458, 2372789030, **S**, RECORD, `dcode`.`product_sold_stock`, unique_product_stock_id, 4604, 761, 458, **428744**
2372789029:4604:761:458, 2372789029, **S**, RECORD, `dcode`.`product_sold_stock`, unique_product_stock_id, 4604, 761, 458, **428744**
2372789028:4604:761:458, 2372789028, **S**, RECORD, `dcode`.`product_sold_stock`, unique_product_stock_id, 4604, 761, 458, **428744**
2372789027:4604:761:458, 2372789027, **S**, RECORD, `dcode`.`product_sold_stock`, unique_product_stock_id, 4604, 761, 458, **428744**
2372789026:4604:761:458, 2372789026, **S**, RECORD, `dcode`.`product_sold_stock`, unique_product_stock_id, 4604, 761, 458, **428744**
2372789025:4604:761:458, 2372789025, **S**, RECORD, `dcode`.`product_sold_stock`, unique_product_stock_id, 4604, 761, 458, **428744**

- 트랜잭션 10개가 동시에 실행 중이었고, **2372789024**가 X(Exclusive Lock)을 갖고 있습니다.

나머지 9개는 S(Shared Lock)인 상태입니다. (product_stock_id = 428744)

### SELECT * FROM INNODB_LOCK_WAITS;

2372789047, 2372789047:4604:761:458, **2372789024**, **2372789024:4604:761:458**
2372789050, 2372789050:4604:761:458, **2372789024**, **2372789024:4604:761:458**
2372789054, 2372789054:4604:761:458, **2372789024**, **2372789024:4604:761:458**
2372789052, 2372789052:4604:761:458, **2372789024**, **2372789024:4604:761:458**
2372789049, 2372789049:4604:761:458, **2372789024**, **2372789024:4604:761:458**
2372789051, 2372789051:4604:761:458, **2372789024**, **2372789024:4604:761:458**
2372789046, 2372789046:4604:761:458, **2372789024**, **2372789024:4604:761:458**
2372789053, 2372789053:4604:761:458, **2372789024**, **2372789024:4604:761:458**
2372789048, 2372789048:4604:761:458, **2372789024**, **2372789024:4604:761:458**

- LOCK_WAITS에는 대기 중인 트랜잭션 9개가 기록되어있는데, 모두 X락을 가진 2372789024 트랜잭션에 의해 막혀있었습니다.

@Transactional을 사용하면 낮은 부하 상황에서는 Deadlock 익셉션이 발생하지 않아서, 이런 경우들을 스프링 자체적으로 효과적으로 처리하고 있었던 것으로 추정합니다.